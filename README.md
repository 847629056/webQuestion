# webQuestion

常问的js面试题

1.js基本数据类型
基本数据类型：number string boolean undefined null bigint symbol 
引用数据类型：object array function

2.基本数据类型和引用数据类型的区别
1）变量的不同内存分配。
基本数据类型是将值存在栈中，他们的值直接存在变量访问的位置。
引用数据类型存在堆中，存储的变量值是一个指针，指向存储对象的内存地址。
2）复制值不同。
基本类型直接复制复制后原始值和新值互不影响
引用类型直接复制的话，新复制的值是一个原值所在堆内存中的地址，修改新数据的值的话会影响原数据
可以利用深拷贝进行复制
3）传递值的区别
基本数据类型通过 = 进行值传递 
对象是通过引用传递，而不是值传递。也就是说，变量赋值只会将地址传递过去。

3.js里面的深浅拷贝
浅拷贝只复制指向某个对象的指针，而不复制对象本身。深拷贝就是能够实现真正意义上的数组和对象的拷贝。
浅拷贝：object.assign() 将所有可枚举属性的值从一个或多个对象复制到源对象
深拷贝：Json.parse(json.Stringfy())  递归

4.new的过程
1）创建实例对象
2）给实例对象属性复制，其__proto__的隐式原型链指向其prototype的显示原型链
3）this上下文指向新的实例
4）执行构造函数
5）构造函数有无return 无return（即return undefined）或return类型为基本类型，则最终return还是新建的实例对象 
若return为一个引用类型，则最终return这个引用类型

5.this指向问题  this永远指向一个对象，this取决于函数调用的位置
1）以函数的方法调用时，this指向window
2)以方法的形式调用，this指向调用方法的那个对象
3）以构造函数调用时，this就是新创建的实例对象
4）call apply bind 自定义this
5)箭头函数没有this this指向包含箭头函数最近一层的函数的this

6.call apply bind 的区别
call和apply是改变了函数的this上下文之后便执行了该函数 
bind是返回了改变this上下文的新函数
call和apply传参不同 第一个参数都是要改变上下文的对象 call第二个参数是列表 apply是数组或类数组

7.事件捕获和事件冒泡
事件捕获是从外向内依次触发 事件冒泡是从内向外依次触发
阻止冒泡：event.stopPropagation()
事件委托利用的就是事件冒泡 将子元素的事件绑定在父元素上，减少事件绑定的次数提升性能
但是注意：祖先元素不会直接处理事件，而是根据event.target得到发生事件的后代元素，通过这个后代元素调用回调函数

8.闭包 闭包存在于嵌套的内部函数中。 闭包就是一个函数有权限访问另一个函数作用域中的变量
作用：延长局部作用域中变量的声明周期 使函数外部可以访问函数内部的数据
缺点：内存泄漏 解决：及时释放引用的外部词法环境
应用：将一个函数作为另一个函数的返回值;将函数作为实参传递给另一个函数调用。
将所有的数据和功能都封装在一个函数内部(私有的)，只向外暴露一个包含n个方法的对象或函数。
模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能。

9.继承
构造函数继承 原型链继承 组合继承 原型式继承 寄生式继承 寄生组合式继承
1）构造函数继承 子类利用call或apply继承父类的构造函数
特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　2、可以继承多个构造函数属性（call多个）。
　　　3、在子实例中可向父实例传参。
缺点：1、只能继承父类构造函数的属性。
　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）
　　　3、每个新实例都有父类构造函数的副本，臃肿
2）原型链继承 子类实例的原型继承父类的实例
特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。
缺点：1、新实例无法向父类构造函数传参。
　　　2、继承单一。
　　　3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！

3）组合继承 结合了两个前面2种继承的优点（传参和复用） 缺点就是调用了两次构造函数

10.作用域和作用域链
js采用的是词法作用域(静态作用域) 包括：全局作用域 函数作用 es6块级作用域
全局作用域就是全局可以使用 函数作用域就是函数内部可以使用 let 或 const声明的变量只在 let 或 const命令所在的代码块 {} 内有效，在 {} 之外不能访问。
作用：隔离变量 不同作用域下同名变量互不影响
作用域链:通过词法环境的对外部词法环境的引用（scope）将作用域链起,变量可通过作用域链逐层向上查找

11.原型和原型链
*显式原型和隐式原型
每个函数对象都有一个prototype,他默认指向一个Object实例对象，即显式原型
每个实例对象都有一个__proto__,即隐式原型，它指向构造函数的prototype
